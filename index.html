<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Silicon Dreams | Build a CPU from Scratch</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@300;400;500&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00aa;
            --neon-green: #00ff88;
            --neon-yellow: #ffee00;
            --neon-orange: #ff6b00;
            --wire-color: #3a3a4a;
            --wire-active: #00f5ff;
            --text-primary: #e0e0e8;
            --text-secondary: #8888a0;
            --text-dim: #4a4a60;
            --panel-border: #2a2a3a;
            --success: #00ff88;
            --error: #ff4466;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Circuit board background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(90deg, var(--panel-border) 1px, transparent 1px),
                linear-gradient(var(--panel-border) 1px, transparent 1px);
            background-size: 40px 40px;
            opacity: 0.3;
            pointer-events: none;
            z-index: 0;
        }

        /* Scan line effect */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }

        /* Header */
        header {
            position: relative;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: linear-gradient(180deg, var(--bg-secondary) 0%, transparent 100%);
            border-bottom: 1px solid var(--panel-border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            position: relative;
        }

        .logo-icon svg {
            width: 100%;
            height: 100%;
        }

        .logo h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
            letter-spacing: 2px;
        }

        .header-stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .stat-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }

        /* Main Layout */
        .game-container {
            display: grid;
            grid-template-columns: 280px 1fr 300px;
            height: calc(100vh - 70px);
            position: relative;
            z-index: 1;
        }

        /* Left Panel - Components */
        .components-panel {
            background: var(--bg-secondary);
            border-right: 1px solid var(--panel-border);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }

        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: var(--text-secondary);
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--panel-border);
        }

        .component-category {
            margin-bottom: 1rem;
        }

        .category-header {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .category-header::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, var(--panel-border), transparent);
        }

        .components-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .component-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.75rem;
            cursor: grab;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .component-item:hover {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.2), inset 0 0 20px rgba(0, 245, 255, 0.05);
            transform: translateY(-2px);
        }

        .component-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .component-item.locked::after {
            content: 'üîí';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
        }

        .component-icon {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .component-name {
            font-size: 0.65rem;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        /* Canvas Area */
        .canvas-area {
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        #circuit-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* Canvas Toolbar */
        .canvas-toolbar {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            background: var(--bg-secondary);
            padding: 0.5rem;
            border-radius: 12px;
            border: 1px solid var(--panel-border);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .toolbar-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--panel-border);
            background: var(--bg-tertiary);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 1.2rem;
        }

        .toolbar-btn:hover {
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }

        .toolbar-btn.active {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }

        .toolbar-btn.run {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--neon-green);
            color: var(--neon-green);
            width: auto;
            padding: 0 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            gap: 0.5rem;
        }

        .toolbar-btn.run:hover {
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }

        /* Right Panel - Level Info */
        .info-panel {
            background: var(--bg-secondary);
            border-left: 1px solid var(--panel-border);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
        }

        .level-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1.25rem;
            position: relative;
            overflow: hidden;
        }

        .level-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta));
        }

        .level-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: var(--neon-cyan);
            letter-spacing: 2px;
            margin-bottom: 0.5rem;
        }

        .level-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
        }

        .level-description {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Truth Table */
        .truth-table-container {
            background: var(--bg-tertiary);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1rem;
        }

        .truth-table-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
        }

        .truth-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .truth-table th {
            background: var(--bg-secondary);
            padding: 0.5rem;
            text-align: center;
            color: var(--neon-cyan);
            font-weight: 500;
            border-bottom: 1px solid var(--panel-border);
        }

        .truth-table td {
            padding: 0.5rem;
            text-align: center;
            border-bottom: 1px solid var(--panel-border);
        }

        .truth-table tr:last-child td {
            border-bottom: none;
        }

        .truth-table .output-col {
            color: var(--neon-green);
        }

        .truth-table .check {
            color: var(--success);
        }

        .truth-table .wrong {
            color: var(--error);
        }

        /* Objectives */
        .objectives {
            background: var(--bg-tertiary);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 1rem;
        }

        .objective-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.5rem 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .objective-check {
            width: 18px;
            height: 18px;
            border: 2px solid var(--panel-border);
            border-radius: 4px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .objective-item.complete .objective-check {
            background: var(--neon-green);
            border-color: var(--neon-green);
            color: var(--bg-primary);
        }

        .objective-item.complete {
            color: var(--text-primary);
        }

        /* Hint System */
        .hint-btn {
            width: 100%;
            padding: 0.75rem;
            background: transparent;
            border: 1px dashed var(--panel-border);
            border-radius: 8px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hint-btn:hover {
            border-color: var(--neon-yellow);
            color: var(--neon-yellow);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .modal-overlay.active .modal {
            transform: scale(1) translateY(0);
        }

        .modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-cyan));
        }

        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        .modal-content {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .modal-btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: var(--bg-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 245, 255, 0.3);
        }

        /* Start Screen */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: all 0.5s ease;
        }

        .start-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .start-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 1rem;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 20px rgba(0, 245, 255, 0.3)); }
            to { filter: drop-shadow(0 0 40px rgba(255, 0, 170, 0.4)); }
        }

        .start-subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--text-secondary);
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 3rem;
        }

        .start-btn {
            padding: 1.25rem 3rem;
            background: transparent;
            border: 2px solid var(--neon-cyan);
            color: var(--neon-cyan);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            background: var(--neon-cyan);
            color: var(--bg-primary);
            box-shadow: 0 0 50px rgba(0, 245, 255, 0.5);
        }

        .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .start-btn:hover::before {
            left: 100%;
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: 100px;
            right: -400px;
            width: 350px;
            background: var(--bg-secondary);
            border: 1px solid var(--neon-yellow);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            z-index: 1001;
            transition: right 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 10px 40px rgba(255, 238, 0, 0.2);
        }

        .achievement-notification.show {
            right: 20px;
        }

        .achievement-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--neon-yellow), var(--neon-orange));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .achievement-text h4 {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            color: var(--neon-yellow);
            margin-bottom: 0.25rem;
        }

        .achievement-text p {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Electron particles */
        .electron {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--neon-cyan);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan);
            pointer-events: none;
        }

        /* Level selector */
        .level-selector {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .level-dot {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid var(--panel-border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .level-dot:hover {
            border-color: var(--neon-cyan);
        }

        .level-dot.current {
            background: var(--neon-cyan);
            border-color: var(--neon-cyan);
            color: var(--bg-primary);
        }

        .level-dot.complete {
            background: rgba(0, 255, 136, 0.2);
            border-color: var(--neon-green);
            color: var(--neon-green);
        }

        .level-dot.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--panel-border);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            color: var(--text-primary);
            max-width: 250px;
            z-index: 1002;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tooltip.visible {
            opacity: 1;
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes electron-flow {
            0% { offset-distance: 0%; }
            100% { offset-distance: 100%; }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--panel-border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div class="start-screen" id="startScreen">
        <h1 class="start-title">SILICON<br>DREAMS</h1>
        <p class="start-subtitle">Build a CPU from scratch</p>
        <button class="start-btn" onclick="startGame()">
            INITIALIZE SYSTEM
        </button>
    </div>

    <!-- Achievement Notification -->
    <div class="achievement-notification" id="achievementNotification">
        <div class="achievement-icon">üèÜ</div>
        <div class="achievement-text">
            <h4>ACHIEVEMENT UNLOCKED</h4>
            <p id="achievementText">First Gate Built!</p>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h2 class="modal-title" id="modalTitle">Level Complete!</h2>
            <div class="modal-content" id="modalContent">
                <p>Excellent work! You've mastered the NOT gate.</p>
            </div>
            <button class="modal-btn" onclick="closeModal()">CONTINUE</button>
        </div>
    </div>

    <!-- Main Game -->
    <header>
        <div class="logo">
            <div class="logo-icon">
                <svg viewBox="0 0 40 40" fill="none">
                    <rect x="5" y="5" width="30" height="30" rx="4" stroke="url(#logoGrad)" stroke-width="2"/>
                    <circle cx="12" cy="12" r="2" fill="#00f5ff"/>
                    <circle cx="20" cy="12" r="2" fill="#00f5ff"/>
                    <circle cx="28" cy="12" r="2" fill="#00f5ff"/>
                    <circle cx="12" cy="20" r="2" fill="#ff00aa"/>
                    <circle cx="20" cy="20" r="2" fill="#ff00aa"/>
                    <circle cx="28" cy="20" r="2" fill="#ff00aa"/>
                    <circle cx="12" cy="28" r="2" fill="#00ff88"/>
                    <circle cx="20" cy="28" r="2" fill="#00ff88"/>
                    <circle cx="28" cy="28" r="2" fill="#00ff88"/>
                    <defs>
                        <linearGradient id="logoGrad" x1="5" y1="5" x2="35" y2="35">
                            <stop stop-color="#00f5ff"/>
                            <stop offset="1" stop-color="#ff00aa"/>
                        </linearGradient>
                    </defs>
                </svg>
            </div>
            <h1>SILICON DREAMS</h1>
        </div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Level</span>
                <span class="stat-value" id="currentLevel">1</span>
            </div>
            <div class="stat">
                <span class="stat-label">Gates Built</span>
                <span class="stat-value" id="gatesBuilt">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Achievements</span>
                <span class="stat-value" id="achievementCount">0/12</span>
            </div>
        </div>
    </header>

    <div class="game-container">
        <!-- Left Panel - Components -->
        <div class="components-panel">
            <h2 class="panel-title">Components</h2>

            <div class="component-category">
                <div class="category-header">Input/Output</div>
                <div class="components-grid">
                    <div class="component-item" draggable="true" data-type="input" data-tooltip="Toggle switch - click to change state">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <rect x="8" y="12" width="20" height="12" rx="6" fill="none" stroke="#00f5ff" stroke-width="2"/>
                                <circle cx="14" cy="18" r="4" fill="#00f5ff"/>
                            </svg>
                        </div>
                        <span class="component-name">Input</span>
                    </div>
                    <div class="component-item" draggable="true" data-type="output" data-tooltip="Output LED - shows the result">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <circle cx="18" cy="18" r="10" fill="none" stroke="#00ff88" stroke-width="2"/>
                                <circle cx="18" cy="18" r="5" fill="#00ff88" opacity="0.3"/>
                            </svg>
                        </div>
                        <span class="component-name">Output</span>
                    </div>
                </div>
            </div>

            <div class="component-category">
                <div class="category-header">Transistors</div>
                <div class="components-grid">
                    <div class="component-item" draggable="true" data-type="nmos" data-tooltip="NMOS Transistor - conducts when gate is HIGH">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <line x1="8" y1="18" x2="14" y2="18" stroke="#00f5ff" stroke-width="2"/>
                                <line x1="14" y1="10" x2="14" y2="26" stroke="#00f5ff" stroke-width="2"/>
                                <line x1="18" y1="10" x2="18" y2="26" stroke="#00f5ff" stroke-width="2"/>
                                <line x1="18" y1="10" x2="28" y2="10" stroke="#00f5ff" stroke-width="2"/>
                                <line x1="18" y1="26" x2="28" y2="26" stroke="#00f5ff" stroke-width="2"/>
                                <text x="22" y="20" fill="#00f5ff" font-size="8" font-family="monospace">N</text>
                            </svg>
                        </div>
                        <span class="component-name">NMOS</span>
                    </div>
                    <div class="component-item" draggable="true" data-type="pmos" data-tooltip="PMOS Transistor - conducts when gate is LOW">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <line x1="8" y1="18" x2="12" y2="18" stroke="#ff00aa" stroke-width="2"/>
                                <circle cx="13" cy="18" r="2" fill="none" stroke="#ff00aa" stroke-width="1.5"/>
                                <line x1="15" y1="10" x2="15" y2="26" stroke="#ff00aa" stroke-width="2"/>
                                <line x1="18" y1="10" x2="18" y2="26" stroke="#ff00aa" stroke-width="2"/>
                                <line x1="18" y1="10" x2="28" y2="10" stroke="#ff00aa" stroke-width="2"/>
                                <line x1="18" y1="26" x2="28" y2="26" stroke="#ff00aa" stroke-width="2"/>
                                <text x="22" y="20" fill="#ff00aa" font-size="8" font-family="monospace">P</text>
                            </svg>
                        </div>
                        <span class="component-name">PMOS</span>
                    </div>
                </div>
            </div>

            <div class="component-category">
                <div class="category-header">Power</div>
                <div class="components-grid">
                    <div class="component-item" draggable="true" data-type="vdd" data-tooltip="VDD - Power supply (always HIGH)">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <line x1="18" y1="8" x2="18" y2="16" stroke="#ffee00" stroke-width="2"/>
                                <line x1="10" y1="8" x2="26" y2="8" stroke="#ffee00" stroke-width="3"/>
                                <text x="10" y="30" fill="#ffee00" font-size="10" font-family="monospace">VDD</text>
                            </svg>
                        </div>
                        <span class="component-name">VDD</span>
                    </div>
                    <div class="component-item" draggable="true" data-type="gnd" data-tooltip="GND - Ground (always LOW)">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <line x1="18" y1="8" x2="18" y2="16" stroke="#888" stroke-width="2"/>
                                <line x1="10" y1="16" x2="26" y2="16" stroke="#888" stroke-width="2"/>
                                <line x1="12" y1="20" x2="24" y2="20" stroke="#888" stroke-width="2"/>
                                <line x1="14" y1="24" x2="22" y2="24" stroke="#888" stroke-width="2"/>
                                <text x="10" y="34" fill="#888" font-size="10" font-family="monospace">GND</text>
                            </svg>
                        </div>
                        <span class="component-name">GND</span>
                    </div>
                </div>
            </div>

            <div class="component-category">
                <div class="category-header">Logic Gates</div>
                <div class="components-grid">
                    <div class="component-item locked" draggable="true" data-type="not" data-tooltip="NOT Gate - Inverts the input" data-unlock="2">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <polygon points="8,8 28,18 8,28" fill="none" stroke="#00f5ff" stroke-width="2"/>
                                <circle cx="30" cy="18" r="3" fill="none" stroke="#00f5ff" stroke-width="2"/>
                            </svg>
                        </div>
                        <span class="component-name">NOT</span>
                    </div>
                    <div class="component-item locked" draggable="true" data-type="nand" data-tooltip="NAND Gate - NOT AND" data-unlock="4">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <path d="M8,8 L18,8 Q28,8 28,18 Q28,28 18,28 L8,28 Z" fill="none" stroke="#00f5ff" stroke-width="2"/>
                                <circle cx="30" cy="18" r="2" fill="none" stroke="#00f5ff" stroke-width="2"/>
                            </svg>
                        </div>
                        <span class="component-name">NAND</span>
                    </div>
                    <div class="component-item locked" draggable="true" data-type="and" data-tooltip="AND Gate - Both inputs must be HIGH" data-unlock="5">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <path d="M8,8 L18,8 Q30,8 30,18 Q30,28 18,28 L8,28 Z" fill="none" stroke="#00ff88" stroke-width="2"/>
                            </svg>
                        </div>
                        <span class="component-name">AND</span>
                    </div>
                    <div class="component-item locked" draggable="true" data-type="or" data-tooltip="OR Gate - Either input can be HIGH" data-unlock="6">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <path d="M8,8 Q14,18 8,28 Q20,28 30,18 Q20,8 8,8" fill="none" stroke="#ff00aa" stroke-width="2"/>
                            </svg>
                        </div>
                        <span class="component-name">OR</span>
                    </div>
                    <div class="component-item locked" draggable="true" data-type="xor" data-tooltip="XOR Gate - Exclusive OR" data-unlock="7">
                        <div class="component-icon">
                            <svg width="36" height="36" viewBox="0 0 36 36">
                                <path d="M10,8 Q16,18 10,28 Q22,28 32,18 Q22,8 10,8" fill="none" stroke="#ffee00" stroke-width="2"/>
                                <path d="M6,8 Q12,18 6,28" fill="none" stroke="#ffee00" stroke-width="2"/>
                            </svg>
                        </div>
                        <span class="component-name">XOR</span>
                    </div>
                </div>
            </div>

            <div class="level-selector">
                <div class="level-dot current" data-level="1">1</div>
                <div class="level-dot locked" data-level="2">2</div>
                <div class="level-dot locked" data-level="3">3</div>
                <div class="level-dot locked" data-level="4">4</div>
                <div class="level-dot locked" data-level="5">5</div>
                <div class="level-dot locked" data-level="6">6</div>
                <div class="level-dot locked" data-level="7">7</div>
                <div class="level-dot locked" data-level="8">8</div>
                <div class="level-dot locked" data-level="9">9</div>
                <div class="level-dot locked" data-level="10">10</div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area">
            <canvas id="circuit-canvas"></canvas>
            <div class="canvas-toolbar">
                <button class="toolbar-btn" id="selectTool" title="Select (V)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                    </svg>
                </button>
                <button class="toolbar-btn active" id="wireTool" title="Wire (W)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M4 12h4m12 0h-4M12 4v4m0 8v4"/>
                        <circle cx="12" cy="12" r="2"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="deleteTool" title="Delete (X)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
                <button class="toolbar-btn" id="clearBtn" title="Clear All">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18M8 6V4h8v2m1 0v14a2 2 0 01-2 2H9a2 2 0 01-2-2V6h10z"/>
                    </svg>
                </button>
                <button class="toolbar-btn run" id="runBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    RUN
                </button>
            </div>
        </div>

        <!-- Right Panel - Level Info -->
        <div class="info-panel">
            <div class="level-card">
                <div class="level-number">LEVEL <span id="levelNum">1</span></div>
                <h3 class="level-title" id="levelTitle">The Transistor</h3>
                <p class="level-description" id="levelDesc">
                    Welcome to Silicon Dreams! Transistors are the building blocks of all digital electronics.
                    An NMOS transistor conducts when its gate is HIGH. Connect the input to the NMOS gate,
                    VDD to the top, GND to the bottom through the NMOS, and see how it works!
                </p>
            </div>

            <div class="truth-table-container">
                <h4 class="truth-table-title">Expected Truth Table</h4>
                <table class="truth-table" id="truthTable">
                    <thead>
                        <tr>
                            <th>IN</th>
                            <th>OUT</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>0</td>
                            <td class="output-col">0</td>
                            <td class="check" id="check0">-</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td class="output-col">1</td>
                            <td class="check" id="check1">-</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="objectives">
                <h4 class="truth-table-title">Objectives</h4>
                <div class="objective-item" id="obj1">
                    <div class="objective-check">‚úì</div>
                    <span id="objText1">Place an NMOS transistor on the canvas</span>
                </div>
                <div class="objective-item" id="obj2">
                    <div class="objective-check">‚úì</div>
                    <span id="objText2">Connect all components with wires</span>
                </div>
                <div class="objective-item" id="obj3">
                    <div class="objective-check">‚úì</div>
                    <span id="objText3">Pass all truth table tests</span>
                </div>
            </div>

            <button class="hint-btn" id="hintBtn">üí° Need a hint?</button>
        </div>
    </div>

    <script>
        // ============================================
        // SILICON DREAMS - Circuit Simulation Game
        // ============================================

        // ============================================
        // SOUND ENGINE - Procedural Synth SFX
        // ============================================
        const AudioEngine = {
            ctx: null,
            masterGain: null,
            enabled: true,

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
            },

            resume() {
                if (this.ctx?.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            // Crisp UI click
            click() {
                if (!this.enabled) return;
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.connect(gain).connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            },

            // Switch toggle - satisfying click
            toggle(state) {
                if (!this.enabled) return;
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(state ? 1200 : 600, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(state ? 2400 : 300, this.ctx.currentTime + 0.08);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                osc.connect(gain).connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            },

            // Component placed - tech drop
            place() {
                if (!this.enabled) return;
                this.init();
                const osc = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc2.type = 'sine';
                osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(150, this.ctx.currentTime + 0.15);
                osc2.frequency.setValueAtTime(600, this.ctx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc2.start();
                osc.stop(this.ctx.currentTime + 0.15);
                osc2.stop(this.ctx.currentTime + 0.1);
            },

            // Wire connected - electric zap
            wireConnect() {
                if (!this.enabled) return;
                this.init();
                const osc = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 2000;
                filter.Q.value = 5;
                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(2000, this.ctx.currentTime + 0.05);
                osc.frequency.exponentialRampToValueAtTime(500, this.ctx.currentTime + 0.12);
                osc2.frequency.setValueAtTime(50, this.ctx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(1000, this.ctx.currentTime + 0.03);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.12);
                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain).connect(this.masterGain);
                osc.start();
                osc2.start();
                osc.stop(this.ctx.currentTime + 0.12);
                osc2.stop(this.ctx.currentTime + 0.12);
            },

            // Delete component
            delete() {
                if (!this.enabled) return;
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain).connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            },

            // Test pass - bright ding
            testPass() {
                if (!this.enabled) return;
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, this.ctx.currentTime);
                osc.frequency.setValueAtTime(1100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.connect(gain).connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            },

            // Test fail - error buzz
            testFail() {
                if (!this.enabled) return;
                this.init();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(180, this.ctx.currentTime);
                osc.frequency.setValueAtTime(150, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.25);
                osc.connect(gain).connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.25);
            },

            // Level complete - victory fanfare
            levelComplete() {
                if (!this.enabled) return;
                this.init();
                const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.12);
                    gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + i * 0.12 + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + i * 0.12 + 0.4);
                    osc.connect(gain).connect(this.masterGain);
                    osc.start(this.ctx.currentTime + i * 0.12);
                    osc.stop(this.ctx.currentTime + i * 0.12 + 0.4);
                });
            },

            // Achievement unlocked - special jingle
            achievement() {
                if (!this.enabled) return;
                this.init();
                const notes = [784, 988, 1175, 1568]; // G5, B5, D6, G6
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc2.type = 'triangle';
                    osc.frequency.value = freq;
                    osc2.frequency.value = freq * 2;
                    gain.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.08);
                    gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + i * 0.08 + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + i * 0.08 + 0.35);
                    osc.connect(gain);
                    osc2.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start(this.ctx.currentTime + i * 0.08);
                    osc2.start(this.ctx.currentTime + i * 0.08);
                    osc.stop(this.ctx.currentTime + i * 0.08 + 0.35);
                    osc2.stop(this.ctx.currentTime + i * 0.08 + 0.35);
                });
            },

            // Boot up - system start
            bootUp() {
                if (!this.enabled) return;
                this.init();
                // Rising sweep
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(4000, this.ctx.currentTime + 0.5);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.6);
                osc.connect(filter).connect(gain).connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.6);
                // Confirmation beep
                setTimeout(() => {
                    const beep = this.ctx.createOscillator();
                    const beepGain = this.ctx.createGain();
                    beep.type = 'sine';
                    beep.frequency.value = 880;
                    beepGain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                    beepGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                    beep.connect(beepGain).connect(this.masterGain);
                    beep.start();
                    beep.stop(this.ctx.currentTime + 0.15);
                }, 500);
            },

            // Simulation running - ambient hum
            simHum: null,
            simGain: null,
            startSimHum() {
                if (!this.enabled || this.simHum) return;
                this.init();
                this.simHum = this.ctx.createOscillator();
                this.simGain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300;
                this.simHum.type = 'sawtooth';
                this.simHum.frequency.value = 60;
                this.simGain.gain.value = 0;
                this.simGain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 0.3);
                this.simHum.connect(filter).connect(this.simGain).connect(this.masterGain);
                this.simHum.start();
            },
            stopSimHum() {
                if (this.simHum && this.simGain) {
                    this.simGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
                    setTimeout(() => {
                        this.simHum?.stop();
                        this.simHum = null;
                        this.simGain = null;
                    }, 300);
                }
            }
        };

        // Game State
        const gameState = {
            currentLevel: 1,
            gatesBuilt: 0,
            achievements: [],
            unlockedComponents: ['input', 'output', 'nmos', 'pmos', 'vdd', 'gnd'],
            completedLevels: [],
            currentTool: 'wire'
        };

        // Level Definitions
        const levels = [
            {
                id: 1,
                title: "The Transistor",
                description: "Welcome to Silicon Dreams! Let's start with the basics. An NMOS transistor acts like a switch that closes when its gate input is HIGH (1). Your goal: connect an input switch to control when current flows from VDD to the output through the NMOS.",
                truthTable: { inputs: 1, outputs: 1, table: [[0, 0], [1, 1]] },
                objectives: [
                    "Place an NMOS transistor",
                    "Connect VDD, GND, input, and output",
                    "Pass all truth table tests"
                ],
                hint: "The NMOS conducts (connects drain to source) when its gate is HIGH. Connect VDD ‚Üí NMOS drain, NMOS source ‚Üí output, input ‚Üí NMOS gate.",
                unlocks: ['not']
            },
            {
                id: 2,
                title: "The NOT Gate (Inverter)",
                description: "Now let's build a NOT gate from transistors! A NOT gate outputs the opposite of its input. Use both PMOS and NMOS transistors. PMOS conducts when gate is LOW, NMOS conducts when gate is HIGH.",
                truthTable: { inputs: 1, outputs: 1, table: [[0, 1], [1, 0]] },
                objectives: [
                    "Use both PMOS and NMOS transistors",
                    "Create an inverter circuit",
                    "Pass all truth table tests"
                ],
                hint: "PMOS on top (connected to VDD), NMOS on bottom (connected to GND). Both gates connected to input. Output comes from the middle where they meet.",
                unlocks: ['nand']
            },
            {
                id: 3,
                title: "Buffer Circuit",
                description: "A buffer outputs the same value as its input but with a stronger signal. Build it using two NOT gates in series (or their transistor equivalents).",
                truthTable: { inputs: 1, outputs: 1, table: [[0, 0], [1, 1]] },
                objectives: [
                    "Create a buffer using inverters",
                    "Signal should pass through unchanged",
                    "Pass all truth table tests"
                ],
                hint: "Two NOT gates in a row: NOT(NOT(A)) = A. You can use the NOT gate component you just unlocked!",
                unlocks: []
            },
            {
                id: 4,
                title: "NAND Gate",
                description: "The NAND gate is the most important gate in computing - you can build ANY other gate from NANDs! It outputs LOW only when BOTH inputs are HIGH.",
                truthTable: { inputs: 2, outputs: 1, table: [[0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 0]] },
                objectives: [
                    "Build a NAND gate from transistors",
                    "Use 2 PMOS and 2 NMOS transistors",
                    "Pass all truth table tests"
                ],
                hint: "PMOS transistors in parallel (top), NMOS transistors in series (bottom). Both inputs go to one PMOS and one NMOS each.",
                unlocks: ['and']
            },
            {
                id: 5,
                title: "AND Gate",
                description: "An AND gate outputs HIGH only when BOTH inputs are HIGH. Build it from a NAND followed by a NOT gate.",
                truthTable: { inputs: 2, outputs: 1, table: [[0, 0, 0], [0, 1, 0], [1, 0, 0], [1, 1, 1]] },
                objectives: [
                    "Build an AND gate",
                    "Use NAND and NOT gates",
                    "Pass all truth table tests"
                ],
                hint: "AND = NOT(NAND(A, B)). Connect a NAND gate's output to a NOT gate.",
                unlocks: ['or']
            },
            {
                id: 6,
                title: "OR Gate",
                description: "An OR gate outputs HIGH when ANY input is HIGH. Build it using NAND gates only!",
                truthTable: { inputs: 2, outputs: 1, table: [[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 1]] },
                objectives: [
                    "Build an OR gate using NANDs",
                    "Use exactly 3 NAND gates",
                    "Pass all truth table tests"
                ],
                hint: "OR(A,B) = NAND(NOT(A), NOT(B)) = NAND(NAND(A,A), NAND(B,B))",
                unlocks: ['xor']
            },
            {
                id: 7,
                title: "XOR Gate",
                description: "The XOR (exclusive OR) gate outputs HIGH when inputs are DIFFERENT. This is crucial for arithmetic!",
                truthTable: { inputs: 2, outputs: 1, table: [[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0]] },
                objectives: [
                    "Build an XOR gate",
                    "Use NAND gates",
                    "Pass all truth table tests"
                ],
                hint: "XOR needs 4 NAND gates. A XOR B = NAND(NAND(A, NAND(A,B)), NAND(B, NAND(A,B)))",
                unlocks: []
            },
            {
                id: 8,
                title: "Half Adder",
                description: "Now we're building actual computing hardware! A half adder adds two 1-bit numbers. It has two outputs: Sum (S) and Carry (C).",
                truthTable: { inputs: 2, outputs: 2, table: [[0, 0, 0, 0], [0, 1, 1, 0], [1, 0, 1, 0], [1, 1, 0, 1]], outputLabels: ['S', 'C'] },
                objectives: [
                    "Build a half adder circuit",
                    "Sum = A XOR B",
                    "Carry = A AND B"
                ],
                hint: "The Sum output is XOR of the inputs. The Carry output is AND of the inputs.",
                unlocks: []
            },
            {
                id: 9,
                title: "2:1 Multiplexer",
                description: "A multiplexer selects between inputs based on a selector signal. When S=0, output=A. When S=1, output=B.",
                truthTable: { inputs: 3, outputs: 1, inputLabels: ['A', 'B', 'S'], table: [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 1, 1, 1], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 1], [1, 1, 1, 1]] },
                objectives: [
                    "Build a 2:1 multiplexer",
                    "S=0 selects input A",
                    "S=1 selects input B"
                ],
                hint: "MUX = OR(AND(A, NOT(S)), AND(B, S))",
                unlocks: []
            },
            {
                id: 10,
                title: "SR Latch",
                description: "Welcome to sequential logic! An SR latch can REMEMBER a value. Set (S) makes Q=1, Reset (R) makes Q=0. This is how computer memory works!",
                truthTable: { inputs: 2, outputs: 1, inputLabels: ['S', 'R'], special: 'latch' },
                objectives: [
                    "Build an SR latch",
                    "Use two NAND gates",
                    "Q should hold its value"
                ],
                hint: "Cross-couple two NAND gates: output of each goes to input of the other.",
                unlocks: []
            }
        ];

        // Circuit State
        let components = [];
        let wires = [];
        let selectedComponent = null;
        let wireStart = null;
        let mousePos = { x: 0, y: 0 };
        let isSimulating = false;

        // Canvas Setup
        const canvas = document.getElementById('circuit-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Component Classes
        class Component {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 60;
                this.inputs = [];
                this.outputs = [];
                this.state = 0;
                this.id = Math.random().toString(36).substr(2, 9);
                this.setupPins();
            }

            setupPins() {
                switch (this.type) {
                    case 'input':
                        this.outputs = [{ x: this.width, y: this.height / 2, state: 0 }];
                        break;
                    case 'output':
                        this.inputs = [{ x: 0, y: this.height / 2, state: 0 }];
                        break;
                    case 'nmos':
                    case 'pmos':
                        this.inputs = [{ x: 0, y: this.height / 2, state: 0, label: 'G' }]; // Gate
                        this.outputs = [
                            { x: this.width, y: 10, state: 0, label: 'D' }, // Drain (top)
                            { x: this.width, y: this.height - 10, state: 0, label: 'S' } // Source (bottom)
                        ];
                        break;
                    case 'vdd':
                        this.outputs = [{ x: this.width / 2, y: this.height, state: 1 }];
                        this.state = 1;
                        break;
                    case 'gnd':
                        this.outputs = [{ x: this.width / 2, y: 0, state: 0 }];
                        this.state = 0;
                        break;
                    case 'not':
                        this.inputs = [{ x: 0, y: this.height / 2, state: 0 }];
                        this.outputs = [{ x: this.width, y: this.height / 2, state: 0 }];
                        break;
                    case 'nand':
                    case 'and':
                    case 'or':
                    case 'xor':
                        this.inputs = [
                            { x: 0, y: this.height / 3, state: 0 },
                            { x: 0, y: (2 * this.height) / 3, state: 0 }
                        ];
                        this.outputs = [{ x: this.width, y: this.height / 2, state: 0 }];
                        break;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                const isActive = this.state === 1;
                const activeColor = '#00f5ff';
                const inactiveColor = '#3a3a4a';

                switch (this.type) {
                    case 'input':
                        this.drawInput(ctx, isActive, activeColor, inactiveColor);
                        break;
                    case 'output':
                        this.drawOutput(ctx, isActive, activeColor);
                        break;
                    case 'nmos':
                        this.drawNMOS(ctx, isActive, activeColor, inactiveColor);
                        break;
                    case 'pmos':
                        this.drawPMOS(ctx, isActive, '#ff00aa', inactiveColor);
                        break;
                    case 'vdd':
                        this.drawVDD(ctx);
                        break;
                    case 'gnd':
                        this.drawGND(ctx);
                        break;
                    case 'not':
                        this.drawNOT(ctx, isActive, activeColor, inactiveColor);
                        break;
                    case 'nand':
                        this.drawNAND(ctx, isActive, activeColor, inactiveColor);
                        break;
                    case 'and':
                        this.drawAND(ctx, isActive, '#00ff88', inactiveColor);
                        break;
                    case 'or':
                        this.drawOR(ctx, isActive, '#ff00aa', inactiveColor);
                        break;
                    case 'xor':
                        this.drawXOR(ctx, isActive, '#ffee00', inactiveColor);
                        break;
                }

                // Draw pins
                this.drawPins(ctx);

                ctx.restore();
            }

            drawInput(ctx, isActive, activeColor, inactiveColor) {
                const color = isActive ? activeColor : inactiveColor;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.fillStyle = isActive ? 'rgba(0, 245, 255, 0.2)' : 'transparent';

                // Switch track
                ctx.beginPath();
                ctx.roundRect(10, 20, 40, 20, 10);
                ctx.fill();
                ctx.stroke();

                // Switch knob
                ctx.fillStyle = color;
                ctx.beginPath();
                const knobX = isActive ? 40 : 20;
                ctx.arc(knobX, 30, 8, 0, Math.PI * 2);
                ctx.fill();

                // Label
                ctx.fillStyle = color;
                ctx.font = '10px "JetBrains Mono"';
                ctx.textAlign = 'center';
                ctx.fillText(isActive ? '1' : '0', 30, 55);

                if (isActive) {
                    ctx.shadowColor = activeColor;
                    ctx.shadowBlur = 15;
                }
            }

            drawOutput(ctx, isActive, activeColor) {
                const color = isActive ? '#00ff88' : '#3a3a4a';
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                // LED housing
                ctx.beginPath();
                ctx.arc(30, 30, 18, 0, Math.PI * 2);
                ctx.stroke();

                // LED glow
                if (isActive) {
                    ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.fill();
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 20;
                }

                // Inner LED
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(30, 30, 10, 0, Math.PI * 2);
                ctx.fill();

                // Label
                ctx.shadowBlur = 0;
                ctx.fillStyle = color;
                ctx.font = '10px "JetBrains Mono"';
                ctx.textAlign = 'center';
                ctx.fillText('OUT', 30, 58);
            }

            drawNMOS(ctx, isActive, activeColor, inactiveColor) {
                const conducting = this.inputs[0]?.state === 1;
                const color = conducting ? activeColor : inactiveColor;

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                // Gate line
                ctx.beginPath();
                ctx.moveTo(0, 30);
                ctx.lineTo(20, 30);
                ctx.stroke();

                // Gate plate
                ctx.beginPath();
                ctx.moveTo(20, 10);
                ctx.lineTo(20, 50);
                ctx.stroke();

                // Channel
                ctx.beginPath();
                ctx.moveTo(25, 10);
                ctx.lineTo(25, 50);
                ctx.stroke();

                // Drain connection (top)
                ctx.beginPath();
                ctx.moveTo(25, 10);
                ctx.lineTo(60, 10);
                ctx.stroke();

                // Source connection (bottom)
                ctx.beginPath();
                ctx.moveTo(25, 50);
                ctx.lineTo(60, 50);
                ctx.stroke();

                // N label
                ctx.fillStyle = color;
                ctx.font = 'bold 12px "JetBrains Mono"';
                ctx.fillText('N', 40, 35);

                // Conducting indicator
                if (conducting) {
                    ctx.fillStyle = 'rgba(0, 245, 255, 0.3)';
                    ctx.fillRect(23, 10, 5, 40);
                    ctx.shadowColor = activeColor;
                    ctx.shadowBlur = 10;
                }
            }

            drawPMOS(ctx, isActive, activeColor, inactiveColor) {
                const conducting = this.inputs[0]?.state === 0;
                const color = conducting ? activeColor : inactiveColor;

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                // Gate line
                ctx.beginPath();
                ctx.moveTo(0, 30);
                ctx.lineTo(15, 30);
                ctx.stroke();

                // Bubble (NOT indicator)
                ctx.beginPath();
                ctx.arc(18, 30, 3, 0, Math.PI * 2);
                ctx.stroke();

                // Gate plate
                ctx.beginPath();
                ctx.moveTo(22, 10);
                ctx.lineTo(22, 50);
                ctx.stroke();

                // Channel
                ctx.beginPath();
                ctx.moveTo(27, 10);
                ctx.lineTo(27, 50);
                ctx.stroke();

                // Drain connection (top)
                ctx.beginPath();
                ctx.moveTo(27, 10);
                ctx.lineTo(60, 10);
                ctx.stroke();

                // Source connection (bottom)
                ctx.beginPath();
                ctx.moveTo(27, 50);
                ctx.lineTo(60, 50);
                ctx.stroke();

                // P label
                ctx.fillStyle = color;
                ctx.font = 'bold 12px "JetBrains Mono"';
                ctx.fillText('P', 42, 35);

                // Conducting indicator
                if (conducting) {
                    ctx.fillStyle = 'rgba(255, 0, 170, 0.3)';
                    ctx.fillRect(25, 10, 5, 40);
                }
            }

            drawVDD(ctx) {
                ctx.strokeStyle = '#ffee00';
                ctx.fillStyle = '#ffee00';
                ctx.lineWidth = 3;

                // Power rail
                ctx.beginPath();
                ctx.moveTo(15, 15);
                ctx.lineTo(45, 15);
                ctx.stroke();

                // Connection line
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(30, 15);
                ctx.lineTo(30, 60);
                ctx.stroke();

                // Label
                ctx.font = 'bold 12px "JetBrains Mono"';
                ctx.fillText('VDD', 15, 10);

                ctx.shadowColor = '#ffee00';
                ctx.shadowBlur = 10;
            }

            drawGND(ctx) {
                ctx.strokeStyle = '#666';
                ctx.fillStyle = '#666';
                ctx.lineWidth = 2;

                // Connection line
                ctx.beginPath();
                ctx.moveTo(30, 0);
                ctx.lineTo(30, 25);
                ctx.stroke();

                // Ground symbol
                ctx.beginPath();
                ctx.moveTo(10, 25);
                ctx.lineTo(50, 25);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(15, 32);
                ctx.lineTo(45, 32);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(20, 39);
                ctx.lineTo(40, 39);
                ctx.stroke();

                // Label
                ctx.font = 'bold 10px "JetBrains Mono"';
                ctx.fillText('GND', 15, 55);
            }

            drawNOT(ctx, isActive, activeColor, inactiveColor) {
                const color = isActive ? activeColor : inactiveColor;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                // Triangle
                ctx.beginPath();
                ctx.moveTo(10, 10);
                ctx.lineTo(45, 30);
                ctx.lineTo(10, 50);
                ctx.closePath();
                ctx.stroke();

                // Bubble
                ctx.beginPath();
                ctx.arc(50, 30, 5, 0, Math.PI * 2);
                ctx.stroke();

                if (isActive) {
                    ctx.shadowColor = activeColor;
                    ctx.shadowBlur = 10;
                }
            }

            drawNAND(ctx, isActive, activeColor, inactiveColor) {
                const color = isActive ? activeColor : inactiveColor;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                // AND shape
                ctx.beginPath();
                ctx.moveTo(10, 10);
                ctx.lineTo(30, 10);
                ctx.quadraticCurveTo(50, 10, 50, 30);
                ctx.quadraticCurveTo(50, 50, 30, 50);
                ctx.lineTo(10, 50);
                ctx.closePath();
                ctx.stroke();

                // Bubble
                ctx.beginPath();
                ctx.arc(55, 30, 4, 0, Math.PI * 2);
                ctx.stroke();
            }

            drawAND(ctx, isActive, activeColor, inactiveColor) {
                const color = isActive ? activeColor : inactiveColor;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(10, 10);
                ctx.lineTo(30, 10);
                ctx.quadraticCurveTo(55, 10, 55, 30);
                ctx.quadraticCurveTo(55, 50, 30, 50);
                ctx.lineTo(10, 50);
                ctx.closePath();
                ctx.stroke();
            }

            drawOR(ctx, isActive, activeColor, inactiveColor) {
                const color = isActive ? activeColor : inactiveColor;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(10, 10);
                ctx.quadraticCurveTo(20, 30, 10, 50);
                ctx.quadraticCurveTo(35, 50, 55, 30);
                ctx.quadraticCurveTo(35, 10, 10, 10);
                ctx.stroke();
            }

            drawXOR(ctx, isActive, activeColor, inactiveColor) {
                const color = isActive ? activeColor : inactiveColor;
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                // Extra curve
                ctx.beginPath();
                ctx.moveTo(5, 10);
                ctx.quadraticCurveTo(15, 30, 5, 50);
                ctx.stroke();

                // OR shape
                ctx.beginPath();
                ctx.moveTo(12, 10);
                ctx.quadraticCurveTo(22, 30, 12, 50);
                ctx.quadraticCurveTo(37, 50, 57, 30);
                ctx.quadraticCurveTo(37, 10, 12, 10);
                ctx.stroke();
            }

            drawPins(ctx) {
                // Draw input pins
                this.inputs.forEach((pin, i) => {
                    ctx.fillStyle = pin.state ? '#00f5ff' : '#3a3a4a';
                    ctx.beginPath();
                    ctx.arc(pin.x, pin.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw output pins
                this.outputs.forEach((pin, i) => {
                    ctx.fillStyle = pin.state ? '#00ff88' : '#3a3a4a';
                    ctx.beginPath();
                    ctx.arc(pin.x, pin.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            containsPoint(px, py) {
                return px >= this.x && px <= this.x + this.width &&
                       py >= this.y && py <= this.y + this.height;
            }

            getPinAt(px, py) {
                const localX = px - this.x;
                const localY = py - this.y;
                const threshold = 15;

                for (let i = 0; i < this.inputs.length; i++) {
                    const pin = this.inputs[i];
                    const dist = Math.sqrt((localX - pin.x) ** 2 + (localY - pin.y) ** 2);
                    if (dist < threshold) {
                        return { type: 'input', index: i, pin };
                    }
                }

                for (let i = 0; i < this.outputs.length; i++) {
                    const pin = this.outputs[i];
                    const dist = Math.sqrt((localX - pin.x) ** 2 + (localY - pin.y) ** 2);
                    if (dist < threshold) {
                        return { type: 'output', index: i, pin };
                    }
                }

                return null;
            }

            simulate() {
                switch (this.type) {
                    case 'input':
                        this.outputs[0].state = this.state;
                        break;
                    case 'output':
                        this.state = this.inputs[0]?.state || 0;
                        break;
                    case 'vdd':
                        this.outputs[0].state = 1;
                        break;
                    case 'gnd':
                        this.outputs[0].state = 0;
                        break;
                    case 'nmos':
                        // NMOS conducts when gate is HIGH
                        if (this.inputs[0]?.state === 1) {
                            // Drain and source are connected
                            this.outputs[1].state = this.outputs[0].state;
                        }
                        break;
                    case 'pmos':
                        // PMOS conducts when gate is LOW
                        if (this.inputs[0]?.state === 0) {
                            this.outputs[1].state = this.outputs[0].state;
                        }
                        break;
                    case 'not':
                        this.outputs[0].state = this.inputs[0]?.state === 1 ? 0 : 1;
                        this.state = this.outputs[0].state;
                        break;
                    case 'nand':
                        this.outputs[0].state = (this.inputs[0]?.state === 1 && this.inputs[1]?.state === 1) ? 0 : 1;
                        this.state = this.outputs[0].state;
                        break;
                    case 'and':
                        this.outputs[0].state = (this.inputs[0]?.state === 1 && this.inputs[1]?.state === 1) ? 1 : 0;
                        this.state = this.outputs[0].state;
                        break;
                    case 'or':
                        this.outputs[0].state = (this.inputs[0]?.state === 1 || this.inputs[1]?.state === 1) ? 1 : 0;
                        this.state = this.outputs[0].state;
                        break;
                    case 'xor':
                        this.outputs[0].state = (this.inputs[0]?.state !== this.inputs[1]?.state) ? 1 : 0;
                        this.state = this.outputs[0].state;
                        break;
                }
            }
        }

        class Wire {
            constructor(fromComponent, fromPin, toComponent, toPin) {
                this.fromComponent = fromComponent;
                this.fromPin = fromPin;
                this.toComponent = toComponent;
                this.toPin = toPin;
                this.id = Math.random().toString(36).substr(2, 9);
            }

            draw(ctx) {
                const from = this.getFromPos();
                const to = this.getToPos();
                const state = this.fromPin.type === 'output'
                    ? this.fromComponent.outputs[this.fromPin.index]?.state
                    : this.fromComponent.inputs[this.fromPin.index]?.state;

                ctx.strokeStyle = state ? '#00f5ff' : '#3a3a4a';
                ctx.lineWidth = state ? 3 : 2;
                ctx.lineCap = 'round';

                if (state) {
                    ctx.shadowColor = '#00f5ff';
                    ctx.shadowBlur = 8;
                }

                ctx.beginPath();
                ctx.moveTo(from.x, from.y);

                // Bezier curve for nice wire routing
                const midX = (from.x + to.x) / 2;
                ctx.bezierCurveTo(midX, from.y, midX, to.y, to.x, to.y);
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Draw electron particles for active wires
                if (state && isSimulating) {
                    this.drawElectrons(ctx, from, to);
                }
            }

            drawElectrons(ctx, from, to) {
                const time = Date.now() / 500;
                for (let i = 0; i < 3; i++) {
                    const t = ((time + i * 0.33) % 1);
                    const midX = (from.x + to.x) / 2;

                    // Approximate bezier position
                    const x = (1-t)*(1-t)*from.x + 2*(1-t)*t*midX + t*t*to.x;
                    const y = (1-t)*(1-t)*from.y + 2*(1-t)*t*((from.y+to.y)/2) + t*t*to.y;

                    ctx.fillStyle = '#00f5ff';
                    ctx.shadowColor = '#00f5ff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            getFromPos() {
                const comp = this.fromComponent;
                const pin = this.fromPin.type === 'output'
                    ? comp.outputs[this.fromPin.index]
                    : comp.inputs[this.fromPin.index];
                return { x: comp.x + pin.x, y: comp.y + pin.y };
            }

            getToPos() {
                const comp = this.toComponent;
                const pin = this.toPin.type === 'input'
                    ? comp.inputs[this.toPin.index]
                    : comp.outputs[this.toPin.index];
                return { x: comp.x + pin.x, y: comp.y + pin.y };
            }
        }

        // Rendering
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#1a1a25';
            ctx.lineWidth = 1;
            const gridSize = 20;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw wires
            wires.forEach(wire => wire.draw(ctx));

            // Draw wire being created
            if (wireStart) {
                ctx.strokeStyle = '#00f5ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const startComp = wireStart.component;
                const startPin = wireStart.pinType === 'output'
                    ? startComp.outputs[wireStart.pinIndex]
                    : startComp.inputs[wireStart.pinIndex];
                ctx.moveTo(startComp.x + startPin.x, startComp.y + startPin.y);
                ctx.lineTo(mousePos.x, mousePos.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw components
            components.forEach(comp => comp.draw(ctx));

            // Selection highlight
            if (selectedComponent) {
                ctx.strokeStyle = '#00f5ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    selectedComponent.x - 5,
                    selectedComponent.y - 5,
                    selectedComponent.width + 10,
                    selectedComponent.height + 10
                );
                ctx.setLineDash([]);
            }

            requestAnimationFrame(render);
        }

        // Simulation
        function simulate() {
            // Reset all pin states
            components.forEach(comp => {
                comp.inputs.forEach(pin => pin.state = 0);
                // Keep VDD and GND states
                if (comp.type !== 'vdd' && comp.type !== 'gnd') {
                    comp.outputs.forEach(pin => pin.state = 0);
                }
            });

            // Propagate signals through wires (multiple iterations for stability)
            for (let iteration = 0; iteration < 10; iteration++) {
                // Copy output states to connected inputs via wires
                wires.forEach(wire => {
                    let sourceState;
                    if (wire.fromPin.type === 'output') {
                        sourceState = wire.fromComponent.outputs[wire.fromPin.index].state;
                    } else {
                        sourceState = wire.fromComponent.inputs[wire.fromPin.index].state;
                    }

                    if (wire.toPin.type === 'input') {
                        wire.toComponent.inputs[wire.toPin.index].state = sourceState;
                    } else {
                        wire.toComponent.outputs[wire.toPin.index].state = sourceState;
                    }
                });

                // Simulate each component
                components.forEach(comp => comp.simulate());
            }
        }

        // Event Handlers
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check for component under cursor
            const comp = components.find(c => c.containsPoint(x, y));

            if (gameState.currentTool === 'select') {
                selectedComponent = comp || null;
                if (comp && comp.type === 'input') {
                    comp.state = comp.state ? 0 : 1;
                    AudioEngine.toggle(comp.state);
                    simulate();
                }
            } else if (gameState.currentTool === 'wire') {
                if (comp) {
                    const pinInfo = comp.getPinAt(x, y);
                    if (pinInfo) {
                        if (!wireStart) {
                            wireStart = {
                                component: comp,
                                pinType: pinInfo.type,
                                pinIndex: pinInfo.index
                            };
                        } else {
                            // Complete the wire
                            const newWire = new Wire(
                                wireStart.component,
                                { type: wireStart.pinType, index: wireStart.pinIndex },
                                comp,
                                { type: pinInfo.type, index: pinInfo.index }
                            );
                            wires.push(newWire);
                            wireStart = null;
                            AudioEngine.wireConnect();
                            simulate();
                            checkObjectives();
                        }
                    }
                } else {
                    wireStart = null;
                }
            } else if (gameState.currentTool === 'delete') {
                if (comp) {
                    // Remove component and connected wires
                    wires = wires.filter(w =>
                        w.fromComponent.id !== comp.id && w.toComponent.id !== comp.id
                    );
                    components = components.filter(c => c.id !== comp.id);
                    AudioEngine.delete();
                    simulate();
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
        });

        // Drag and Drop
        document.querySelectorAll('.component-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                if (item.classList.contains('locked')) {
                    e.preventDefault();
                    return;
                }
                e.dataTransfer.setData('componentType', item.dataset.type);
            });
        });

        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('componentType');
            if (!type) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 30;
            const y = e.clientY - rect.top - 30;

            const comp = new Component(type, x, y);
            components.push(comp);
            gameState.gatesBuilt++;
            document.getElementById('gatesBuilt').textContent = gameState.gatesBuilt;
            AudioEngine.place();

            // First gate achievement
            if (gameState.gatesBuilt === 1) {
                unlockAchievement('First Steps', 'Placed your first component!');
            }

            checkObjectives();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'v':
                    setTool('select');
                    break;
                case 'w':
                    setTool('wire');
                    break;
                case 'x':
                case 'delete':
                case 'backspace':
                    if (selectedComponent) {
                        wires = wires.filter(w =>
                            w.fromComponent.id !== selectedComponent.id &&
                            w.toComponent.id !== selectedComponent.id
                        );
                        components = components.filter(c => c.id !== selectedComponent.id);
                        selectedComponent = null;
                        AudioEngine.delete();
                        simulate();
                    }
                    break;
            }
        });

        // Toolbar buttons
        document.getElementById('selectTool').addEventListener('click', () => { AudioEngine.click(); setTool('select'); });
        document.getElementById('wireTool').addEventListener('click', () => { AudioEngine.click(); setTool('wire'); });
        document.getElementById('deleteTool').addEventListener('click', () => { AudioEngine.click(); setTool('delete'); });
        document.getElementById('clearBtn').addEventListener('click', () => {
            AudioEngine.delete();
            components = [];
            wires = [];
            selectedComponent = null;
            wireStart = null;
        });
        document.getElementById('runBtn').addEventListener('click', () => {
            isSimulating = !isSimulating;
            const btn = document.getElementById('runBtn');
            if (isSimulating) {
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg> PAUSE';
                AudioEngine.startSimHum();
                runTests();
            } else {
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> RUN';
                AudioEngine.stopSimHum();
            }
        });

        function setTool(tool) {
            gameState.currentTool = tool;
            document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool')?.classList.add('active');
            wireStart = null;
        }

        // Level System
        function loadLevel(levelNum) {
            const level = levels[levelNum - 1];
            if (!level) return;

            gameState.currentLevel = levelNum;
            document.getElementById('currentLevel').textContent = levelNum;
            document.getElementById('levelNum').textContent = levelNum;
            document.getElementById('levelTitle').textContent = level.title;
            document.getElementById('levelDesc').textContent = level.description;

            // Update truth table
            updateTruthTable(level.truthTable);

            // Update objectives
            level.objectives.forEach((obj, i) => {
                document.getElementById('objText' + (i + 1)).textContent = obj;
                document.getElementById('obj' + (i + 1)).classList.remove('complete');
            });

            // Clear canvas
            components = [];
            wires = [];
            selectedComponent = null;

            // Update level dots
            document.querySelectorAll('.level-dot').forEach(dot => {
                const dotLevel = parseInt(dot.dataset.level);
                dot.classList.remove('current', 'complete', 'locked');
                if (dotLevel === levelNum) {
                    dot.classList.add('current');
                } else if (gameState.completedLevels.includes(dotLevel)) {
                    dot.classList.add('complete');
                } else if (dotLevel > levelNum && !gameState.completedLevels.includes(dotLevel - 1)) {
                    dot.classList.add('locked');
                }
            });

            // Unlock components for this level
            updateUnlockedComponents();
        }

        function updateTruthTable(tt) {
            const tbody = document.querySelector('#truthTable tbody');
            const thead = document.querySelector('#truthTable thead tr');

            // Update header
            let headerHtml = '';
            if (tt.inputLabels) {
                tt.inputLabels.forEach(label => headerHtml += `<th>${label}</th>`);
            } else {
                for (let i = 0; i < tt.inputs; i++) {
                    headerHtml += `<th>IN${tt.inputs > 1 ? i + 1 : ''}</th>`;
                }
            }
            if (tt.outputLabels) {
                tt.outputLabels.forEach(label => headerHtml += `<th class="output-col">${label}</th>`);
            } else {
                for (let i = 0; i < tt.outputs; i++) {
                    headerHtml += `<th class="output-col">OUT${tt.outputs > 1 ? i + 1 : ''}</th>`;
                }
            }
            headerHtml += '<th></th>';
            thead.innerHTML = headerHtml;

            // Update body
            let bodyHtml = '';
            if (tt.table) {
                tt.table.forEach((row, i) => {
                    bodyHtml += '<tr>';
                    row.forEach((val, j) => {
                        if (j < tt.inputs) {
                            bodyHtml += `<td>${val}</td>`;
                        } else {
                            bodyHtml += `<td class="output-col">${val}</td>`;
                        }
                    });
                    bodyHtml += `<td class="check" id="check${i}">-</td></tr>`;
                });
            }
            tbody.innerHTML = bodyHtml;
        }

        function runTests() {
            const level = levels[gameState.currentLevel - 1];
            if (!level || !level.truthTable.table) return;

            const inputs = components.filter(c => c.type === 'input');
            const outputs = components.filter(c => c.type === 'output');

            if (inputs.length < level.truthTable.inputs || outputs.length < level.truthTable.outputs) {
                return;
            }

            let allPassed = true;

            level.truthTable.table.forEach((row, i) => {
                // Set input states
                for (let j = 0; j < level.truthTable.inputs; j++) {
                    if (inputs[j]) inputs[j].state = row[j];
                }

                // Simulate
                simulate();

                // Check outputs
                let rowPassed = true;
                for (let j = 0; j < level.truthTable.outputs; j++) {
                    const expected = row[level.truthTable.inputs + j];
                    const actual = outputs[j]?.state || 0;
                    if (actual !== expected) rowPassed = false;
                }

                const checkEl = document.getElementById('check' + i);
                if (checkEl) {
                    checkEl.textContent = rowPassed ? '‚úì' : '‚úó';
                    checkEl.className = rowPassed ? 'check' : 'wrong';
                }

                if (!rowPassed) allPassed = false;
            });

            if (allPassed) {
                AudioEngine.testPass();
                AudioEngine.stopSimHum();
                completeLevel();
            } else {
                AudioEngine.testFail();
            }
        }

        function checkObjectives() {
            const level = levels[gameState.currentLevel - 1];
            if (!level) return;

            // Basic objective checks
            const hasRequiredComponents = components.length > 0;
            const hasWires = wires.length > 0;

            if (hasRequiredComponents) {
                document.getElementById('obj1').classList.add('complete');
            }
            if (hasWires) {
                document.getElementById('obj2').classList.add('complete');
            }
        }

        function completeLevel() {
            const level = levels[gameState.currentLevel - 1];

            if (!gameState.completedLevels.includes(gameState.currentLevel)) {
                gameState.completedLevels.push(gameState.currentLevel);

                // Unlock new components
                if (level.unlocks) {
                    level.unlocks.forEach(comp => {
                        if (!gameState.unlockedComponents.includes(comp)) {
                            gameState.unlockedComponents.push(comp);
                        }
                    });
                }

                document.getElementById('obj3').classList.add('complete');

                // Play victory sound
                AudioEngine.levelComplete();

                // Show completion modal
                showModal(
                    'Level Complete!',
                    `<p>Excellent work! You've mastered: <strong>${level.title}</strong></p>
                     ${level.unlocks?.length ? `<p style="color: var(--neon-green); margin-top: 1rem;">üîì Unlocked: ${level.unlocks.join(', ').toUpperCase()}</p>` : ''}`
                );

                // Level completion achievement
                if (gameState.completedLevels.length === 1) {
                    unlockAchievement('Circuit Novice', 'Completed your first level!');
                } else if (gameState.completedLevels.length === 5) {
                    unlockAchievement('Logic Master', 'Completed 5 levels!');
                } else if (gameState.completedLevels.length === 10) {
                    unlockAchievement('Silicon Architect', 'Completed all 10 levels!');
                }
            }
        }

        function updateUnlockedComponents() {
            document.querySelectorAll('.component-item').forEach(item => {
                const type = item.dataset.type;
                const unlockLevel = parseInt(item.dataset.unlock) || 1;

                if (gameState.unlockedComponents.includes(type) || gameState.currentLevel >= unlockLevel) {
                    item.classList.remove('locked');
                    item.draggable = true;
                } else {
                    item.classList.add('locked');
                    item.draggable = false;
                }
            });
        }

        // Modal
        function showModal(title, content) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalContent').innerHTML = content;
            document.getElementById('modalOverlay').classList.add('active');
        }

        function closeModal() {
            AudioEngine.click();
            document.getElementById('modalOverlay').classList.remove('active');

            // Auto advance to next level
            if (gameState.currentLevel < levels.length) {
                loadLevel(gameState.currentLevel + 1);
            }
        }

        // Achievements
        function unlockAchievement(title, description) {
            if (gameState.achievements.includes(title)) return;

            gameState.achievements.push(title);
            document.getElementById('achievementCount').textContent =
                `${gameState.achievements.length}/12`;

            document.getElementById('achievementText').textContent = description;
            const notif = document.getElementById('achievementNotification');
            notif.classList.add('show');
            AudioEngine.achievement();

            setTimeout(() => notif.classList.remove('show'), 4000);
        }

        // Hints
        document.getElementById('hintBtn').addEventListener('click', () => {
            AudioEngine.click();
            const level = levels[gameState.currentLevel - 1];
            if (level?.hint) {
                showModal('üí° Hint', `<p>${level.hint}</p>`);
            }
        });

        // Level selector
        document.querySelectorAll('.level-dot').forEach(dot => {
            dot.addEventListener('click', () => {
                const level = parseInt(dot.dataset.level);
                if (!dot.classList.contains('locked')) {
                    AudioEngine.click();
                    loadLevel(level);
                }
            });
        });

        // Tooltip
        const tooltip = document.getElementById('tooltip');
        document.querySelectorAll('[data-tooltip]').forEach(el => {
            el.addEventListener('mouseenter', (e) => {
                tooltip.textContent = el.dataset.tooltip;
                tooltip.classList.add('visible');
            });
            el.addEventListener('mousemove', (e) => {
                tooltip.style.left = e.clientX + 15 + 'px';
                tooltip.style.top = e.clientY + 15 + 'px';
            });
            el.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
            });
        });

        // Start Game
        function startGame() {
            AudioEngine.resume();
            AudioEngine.bootUp();
            document.getElementById('startScreen').classList.add('hidden');
            loadLevel(1);
            render();
        }

        // Initialize
        render();
    </script>
</body>
</html>
